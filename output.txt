[0.00 --> 5.38]  한글과 한국어가 너무 우수하다 보니까 이것 때문에 IT업계 사람들은 가끔 불편한 부분들이 많이 있습니다.
[5.82 --> 8.70]  일단 단어에 붙을 수 있는 조사가 진짜 너무 많다는 건데
[8.70 --> 13.96]  여기서 조사들을 다 떼어야 이제 데이터 분석할 때도 쓰고 검색 기능 만들 때도 쓰고 그러는데
[13.96 --> 16.80]  영어 이런 거에 비해서 떼기가 매우 힘든 편이고요.
[17.34 --> 20.14]  한글의 우수성 덕분에 줄임말 표현도 너무 많습니다.
[20.34 --> 24.04]  예를 들어서 울트라 리스크를 대부분 울라리라고 줄여서 말하는데
[24.04 --> 29.86]  그러면 사람들이 울라리라고 검색을 했을 때 울트라 리스크라는 검색 결과도 나오게 하려면 어떻게 해야 돼요?
[30.22 --> 34.40]  다른 나라 언어들도 비슷하겠지만 한국이 특히나 이런 게 잦은 것 같기도 합니다.
[34.94 --> 37.62]  한글은 구조상 신조어 만들기가 매우 쉽습니다.
[37.62 --> 41.14]  그래서 창의적인 단어나 비속어 이런 것들도 되게 많기 때문에
[41.14 --> 43.76]  이런 것들을 검열해야 될 때 매우 힘들고요.
[44.10 --> 47.70]  그리고 한글은 특이하게도 문자들을 조합해서 만들어야 되기 때문에
[47.70 --> 50.82]  타이핑할 땐 한국어 IME라는 입력기를 써야 돼요.
[51.12 --> 56.62]  근데 미국 형님들이 브라우저나 OS를 업데이트해 줄 때 한글의 존재를 까먹는 경우가 많아서
[56.62 --> 59.94]  한글 입력이 이상해지는 IME 버그 같은 게 굉장히 많고요.
[60.00 --> 62.62]  디자인하는 사람들도 가끔 불만이 있을 텐데
[62.62 --> 66.00]  한글은 최대 1만자의 유니크한 조합이 나올 수 있기 때문에
[66.00 --> 70.02]  한글 폰트 하나 만들려면 1만자를 다 디자인해 놔야 되는 거예요.
[70.38 --> 74.92]  자주 쓰는 글자만 고른다고 해도 2천자에서 3천자 정도를 디자인해야 되는 거고요.
[75.16 --> 77.48]  그래서 폰트 파일 하나 사이즈도 되게 크기 때문에
[77.48 --> 80.76]  웹페이지에 폰트 같은 것도 다양하게 많이 활용할 수가 없어요.
[81.24 --> 83.12]  그리고 한글의 가장 우수한 점이 뭐냐면
[83.12 --> 87.34]  자음 몇 개만 나열해도 이게 무슨 뜻인지 추론이 된다는 건데
[87.34 --> 89.34]  그래서 요즘은 검색창에 자음만 입력해놓고
[89.34 --> 89.98]  자음 몇 개만 나열해도 이게 무슨 뜻인지 추론이 된다는 건데
[89.98 --> 92.62]  뭔가 검색되길 기대하는 사람들이 있습니다.
[92.82 --> 96.96]  그래서 개발하는 사람들은 초성 검색 기능을 따로 구현해야 되기도 합니다.
[98.94 --> 100.42]  초성 검색을 구현하려면
[100.42 --> 103.38]  컴퓨터야 이제 ㅂㅂ으로 시작하는 단어를 전부 알려줘
[103.38 --> 105.46]  이런 식으로 명령을 내릴 수 있으면 좋겠지만
[105.46 --> 108.68]  컴퓨터는 멍청하기 때문에 이런 식으로 명령을 내릴 수는 없고요.
[109.12 --> 112.62]  여러분들이 직접 로직을 짜주셔야 되는데 방법은 여러 가지가 있을 수 있습니다.
[113.26 --> 116.40]  예를 들면 이런 이름들에서 초성 검색을 해야 된다고 칩시다.
[116.40 --> 119.10]  그러면 이름들에 초성을 먼저 구한 다음에
[119.10 --> 122.04]  유저가 입력한 초성이랑 이거랑 비교하면 되는 거 아니에요?
[122.40 --> 123.34]  그러면 쉬울 것 같습니다.
[123.54 --> 126.92]  근데 코드를 어떻게 짜야 이름들에서 초성을 구할 수 있게요?
[127.58 --> 130.92]  사람들은 그냥 봤을 때 이렇게 자음 부분만 딱 꺼내올 수가 있겠으나
[130.92 --> 133.40]  컴퓨터는 이게 안 되기 때문에 어렵습니다.
[133.66 --> 135.86]  왜냐하면 한글 글자 하나를 저장할 때
[135.86 --> 140.02]  이렇게 세 개의 자음 모음을 각각 이렇게 저장해 주는 게 아니라
[140.02 --> 143.24]  글자 하나 자체가 하나의 그냥 데이터 덩어리이기 때문에
[143.24 --> 145.90]  이 안에서 자음만 쉽게 꺼내고 그럴 수가 없습니다.
[145.90 --> 149.08]  그래서 어떤 글자에 초성을 구하고 싶으면 어떤 식으로?
[149.10 --> 151.84]  해야 되냐면 비효율적으로 출원할 수밖에 없는 거예요.
[151.84 --> 154.82]  어떤 문자가 가 부터 기 사이에 있으면
[154.82 --> 158.06]  이 문자의 초성은 기억이다 라고 출원하시면 되겠습니다.
[158.06 --> 159.46]  그런 식으로 코드를 짜면 되는데
[159.46 --> 163.38]  다행히 자바스크립트에선 부등호로 문자 비교도 가능하기 때문에
[163.38 --> 167.16]  어떤 문자가 가부터 기 사이에 있는지 쉽게 테스트해 볼 수 있고요.
[167.16 --> 170.20]  아니면 문자 하나를 유니코드 숫자 같은 걸로 변환할 수가 있는데
[170.20 --> 173.16]  예를 들어서 자바스크립트에선 이런 식으로 코드를 짜시면
[173.16 --> 176.48]  가의 유니코드 버전 숫자가 나오게 됩니다.
[176.48 --> 178.50]  그래서 가부터 기까지의 문자를 유니코드로 변환할 수 있습니다.
[178.50 --> 179.08]  그래서 가부터 기까지의 문자를 유니코드로 변환할 수 있습니다.
[179.08 --> 181.08]  가부터 기까지의 문자를 유니코드 버전을 변환하면 이런 식으로 숫자가 나오기 때문에
[181.08 --> 185.50]  특정 문자의 유니코드가 이 숫자 사이에 있으면 초성이 기억이다 라고 할 수 있는 거예요.
[185.50 --> 187.84]  그렇게 해야 코드가 좀 줄어들 것 같긴 한데
[187.84 --> 191.52]  아무튼 어떻게 하든 간에 이름들의 초성을 전부 구해놓은 다음에
[191.52 --> 195.80]  유저 검색어가 들어있는 초성만 필터링 해주면 이게 초성 검색이에요.
[197.14 --> 199.56]  아니면 정규식이라는 걸 쓰셔도 됩니다.
[200.06 --> 201.46]  원래 정규식이 좀 느리긴 한데
[201.46 --> 205.00]  근데 정규식을 그렇게 복잡하게 쓰진 않을 거기 때문에 크게 상관없고요.
[205.00 --> 208.74]  그래서 예를 들어서 유저가 기억 니은 이런 식으로 초성을 입력하면
[208.74 --> 210.94]  정규식을 이런 식으로 만들어 버리는 거예요.
[211.32 --> 215.06]  이게 뭐냐면 첫 글자에 가부터 기까지의 문자가 포함되어 있냐
[215.06 --> 219.06]  그 다음에 두 번째 문자에 나부터 니까지의 문자가 포함되어 있냐
[219.06 --> 220.18]  라고 이렇게 물어보는 거예요.
[220.60 --> 224.74]  이걸 모든 이름에다가 쭉 대입해보면 초성 검색을 쉽게 완성할 수 있을 것 같네요.
[225.04 --> 228.18]  아니면 부자들은 돈 내고 GPT한테 이렇게 물어봐도 될 것 같긴 하고요.
[229.94 --> 234.78]  근데 데이터가 얼마 없으면 진짜로 아무렇게나 GPT 써도 전혀 상관이 없을 것 같은데
[234.78 --> 238.24]  근데 이름이 10억 개에 저장되어 있는 데이터베이스에서
[238.24 --> 240.24]  이제 초성 검색을 하고 싶으면 어떻게 할 거예요?
[240.24 --> 245.12]  어떤 분들은 데이터베이스에 엄청난 반복문과 함께 함수 같은 걸 하나 만들어 놓고
[245.12 --> 249.12]  이렇게 초성 검색이 들어올 때마다 이걸 실행하는 사람들도 있습니다.
[249.12 --> 254.12]  근데 가장 좋은 건 검색할 글들을 초성으로 미리 변환해서 저장해 놓는 거예요.
[254.12 --> 258.12]  그리고 여기다가 인덱스 만들어 두면 초성을 되게 쉽게 검색할 수 있는 거니까요.
[259.62 --> 263.82]  아니면 대가리를 쓰기 싫은 분들은 토스 사내에서 쓰던 라이브러리도 있습니다.
[263.82 --> 268.22]  es 한글이라는 자바스크립트 라이브러리인데 설치하면 초성 검색해 주는 거.
[268.22 --> 270.22]  자음이랑 모음을 분리해 주는 거.
[270.22 --> 272.22]  그리고 자동으로 조사를 붙여주는 거.
[272.22 --> 274.22]  이런 기능들을 쉽게 사용할 수 있고요.
[274.22 --> 277.22]  가장 유용한 게 한글 인클루스라는 함수 같은데
[277.22 --> 281.22]  우리가 가끔 검색어 추천 서비스를 구현할 때가 있습니다.
[281.22 --> 285.22]  예를 들어 사까지만 검색어를 입력하면 사과를 추천해 주고 그런 건데
[285.22 --> 291.22]  근데 사과를 검색할 때 이제 사 그리고 기억을 입력하면 이런 식으로 문자가 바뀌지 않습니까?
[291.22 --> 296.22]  그러면 사기라는 문자가 되어서 사과라는 단어 추천이 안 되는 경우들이 있는데
[296.22 --> 298.22]  이걸 해결하고 싶으면 이런 거 써 보셔도 되는 거고요.
[298.22 --> 302.22]  참고로 소스 코드 보면 한글의 우수성을 잘 활용하고 있는 걸 볼 수 있는데
[302.22 --> 304.22]  여러분들 조사가 영어로 보게요.
[304.22 --> 310.22]  포스트 프로포지션 뭐 이런 건데 이런 걸로 함수명을 지어 놓으면 솔직히 알아듣기 힘들 것 같습니다.
[310.22 --> 314.22]  그럴 땐 그냥 화끈하게 조사라고 이렇게 이름 지으시면 되고요.
[314.22 --> 316.22]  초성을 영어로 번역하면 보게요.
[316.22 --> 320.22]  굳이 번역을 하자면 퍼스트 콘소넌트 이런 식으로 표현할 수 있을 것 같은데
[320.22 --> 322.22]  근데 이러면 누가 알아듣습니까?
[322.22 --> 325.22]  그래서 처음에는 이런 식으로 근본 없는 이름으로 함수를 만들었다가
[325.22 --> 328.22]  get 초성으로 자랑스럽게 바꿔버린 걸 볼 수 있습니다.
[328.22 --> 331.22]  그리고 한글 다루는 라이브러리라 그런지
[331.22 --> 335.22]  테스트 문구들도 원래 영어로 적었다가 다시 한글로 작성한 걸 볼 수 있습니다.
[335.22 --> 339.22]  그래서 세종대왕님도 요거 보면 별표 찍어줄 거고요.
